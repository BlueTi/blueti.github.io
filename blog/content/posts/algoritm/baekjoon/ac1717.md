---
title: "집합의 표현"
date: "2021-07-03T15:53:37.121Z"
template: "post"
draft: false
slug: "ac1717"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "1717"
  - "유니온 파인드"
  - "문제풀이"
  - "java"
description: "백준 1717번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1717)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1717">https://www.acmicpc.net/problem/1717</a></div>

---

- 연결된 숫자들을 찾는 배열을 선언합니다.
- 부모노드를 숫자가 더 작은 쪽으로 몰아 넣어준다.

---



```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;

    static int[] ar;

    //부모를 찾는 함수
    public static int findROOT(int index) {
        //부모노드는 위가 없으므로 자기자신을 찾았다면 돌려준다.
        if (ar[index] == index) {
            return index;
        }
        // 현재 인덱스 값에 부모노드 값을 넣으면서 돌려준다.
        return ar[index] = findROOT(ar[index]);
    }

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        sb = new StringBuilder();

        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken());
        ar = new int[n + 1];
        //각 노드위치에 자기 값을 넣는다.
        for (int i = 0; i <= n; i++)
            ar[i] = i;

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int c = Integer.parseInt(st.nextToken()), a = Integer.parseInt(st.nextToken()),
                    b = Integer.parseInt(st.nextToken());
            //c가 0일 경우 연결
            if (c == 0) {
                a = findROOT(a);
                b = findROOT(b);
                //b가 더 작을 경우 a의 부모에 b를 입력
                if (a > b)
                    ar[a] = b;
                //a가 더 작을 경우 b의 부모에 a를 입력
                else if (a < b)
                    ar[b] = a;
            } else if (c == 1) { //c가 1일 경우 부모노드를 확인하여 출력
                sb.append((findROOT(a) == findROOT(b) ? "YES" : "NO") + "\n");
            }
        }
        bw.write(sb.toString());
        bw.flush();
    }
}
```
