---
title: "탈출"
date: "2021-05-02T19:21:37.121Z"
template: "post"
draft: false
slug: "ac3055"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "3055"
  - "자료구조"
  - "그래프 이론"
  - "그래프 탐색"
  - "너비 우선 탐색"
  - "java"
description: "백준 3055번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/3055)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/3055">https://www.acmicpc.net/problem/3055</a></div>

---

- 물웅덩이가 '시간마다' 번지고 고슴도치가 '시간마다' 움직인다.
- BFS를 써서 푼다.
- 일단 물이 먼저 퍼지고, 그 다음 고슴도치가 움직인다.
- 물의 위치를 큐에 넣고 탐색을 처음 큐 길이만큼 돌려서 새로 넣은 물의 위치는 다음 타임에 한다.
- 거리를 적어놓는 int배열 dist를 만들어서 고슴도치가 움직일때마다 현위치에서 이동할 곳에 +1을 넣어준다.
- 고슴도치가 목적지에 도착하면 고슴도치 위치 큐에 넣지 않아 큐가 비가 되어 while문을 멈춘다.

---


```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.LinkedList;
import java.util.Queue;

class Main {

    public static void main(String[] args) throws java.lang.Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] input = br.readLine().split(" ");
        int N = Integer.parseInt(input[0]), M = Integer.parseInt(input[1]);
        char[][] map = new char[N + 1][M + 1];
        int[][] directions = new int[][] { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } }, dist = new int[N + 1][M + 1];
        int[] dest = new int[2];
        Queue<int[]> waterQ = new LinkedList<int[]>(), sonicQ = new LinkedList<int[]>();

        for (int i = 0; i < N; i++) {
            char[] temp = br.readLine().toCharArray();
            for (int j = 0; j < M; j++) {
                map[i][j] = temp[j];
                if (temp[j] == '*')
                    waterQ.add(new int[] { i, j });
                else if (temp[j] == 'S')
                    sonicQ.add(new int[] { i, j });
                else if (temp[j] == 'D')
                    dest = new int[] { i, j };
            }
        }

        while (!sonicQ.isEmpty()) {
            int size = waterQ.size();
            while (size-- > 0) {
                int[] pos = waterQ.poll();
                for (int[] dir : directions) {
                    int next_y = pos[0] + dir[0], next_x = pos[1] + dir[1];
                    if (!(next_y < 0 || next_x < 0 || next_y >= N || next_x >= M)
                            && (map[next_y][next_x] == '.' || map[next_y][next_x] == 'S')) {
                        map[next_y][next_x] = '*';
                        waterQ.add(new int[] { next_y, next_x });
                    }
                }
            }

            size = sonicQ.size();
            while (size-- > 0) {
                int[] pos = sonicQ.poll();
                for (int[] dir : directions) {
                    int next_y = pos[0] + dir[0], next_x = pos[1] + dir[1];
                    if (!(next_y < 0 || next_x < 0 || next_y >= N || next_x >= M)
                            && (map[next_y][next_x] != '*' && map[next_y][next_x] != 'X')
                            && dist[next_y][next_x] == 0) {
                        dist[next_y][next_x] = dist[pos[0]][pos[1]] + 1;
                        sonicQ.add(new int[] { next_y, next_x });
                    }
                }
            }
        }

        int result = dist[dest[0]][dest[1]];
        bw.write(result != 0 ? result + "" : "KAKTUS");
        bw.flush();
    }
}
```