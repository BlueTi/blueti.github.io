---
title: 소수 찾기
date: "2021-04-10T20:17:37.121Z"
template: "post"
draft: false
slug: "ac1978"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "1978"
  - "수학"
  - "정수론"
  - "java"
description: "백준 1978번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1978)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1978">https://www.acmicpc.net/problem/1978</a></div>

---

- 1과 자기 자신 외에 나눠지지 않는 소수를 찾는 문제이다.
- 처음 생각한 코드는 2부터 주어진 수의 제곱근까지 반복시켜 소수를 판별했다.

---

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()), count = 0;
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            int num = Integer.parseInt(st.nextToken());
            if (num == 1)
                continue;
            boolean flag = true;
            for (int j = 2; j <= Math.sqrt(num); j++) {
                if (num % j == 0) {
                    flag = false;
                    break;
                }
            }
            if (flag)
                count++;
        }
        System.out.println(count);
    }
}
```

---

- 하지만 걸린 시간과 메로리가 더 짧은 방법이 있었다.
- 최대 1000까지 입력이므로 불린형 배열에 true false로 소수 판별을 미리 만들어 놓고 인덱스로 찾아가서 true면 출력.

---


```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        boolean[] ar = new boolean[1001];
        int n = Integer.parseInt(br.readLine());
        int count = 0;

        StringTokenizer st = new StringTokenizer(br.readLine());

        for (int i = 0; i < n; i++) {
            ar[Integer.parseInt(st.nextToken())] = true;
        }

        for (int i = 2; i <= 1000; i++) {
            if (ar[i])
                count++;
            for (int j = 2;; j++) {
                if (i * j > 1000)
                    break;
                ar[i * j] = false;
            }
        }
        bw.write(count + "");
        bw.flush();
    }
}
```