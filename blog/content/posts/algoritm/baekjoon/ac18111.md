---
title: 마인크래프트
date: "2021-04-21T10:10:37.121Z"
template: "post"
draft: false
slug: "ac18111"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "18111"
  - "문제풀이"
  - "java"
description: "백준 18111번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/18111)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/18111">https://www.acmicpc.net/problem/18111</a></div>

---

- 땅을 평평하게 하기 위해 파거나 쌓는 작업을 하는데 그 중 가장 높은 높이를 출력해야한다.
- 반복의 범위를 줄이기 위해 높이 최저,최고 값을 정해준다.
- 최저값부터 최고값까지 각 칸과의 거리를 구하여 음수가 나오면 파내는것이고 양수가 나오면 더해줘야하므로 가방에서 더해준다.
- 배열 탐색을 끝내고 가방에서 쓸 수 있는 블록 보다 더 쓸 경우는 넘어간다.
- 블록이 사용가능한 갯수면 최소 시간을 비교하여 대입한다.

---



```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] input = br.readLine().split(" ");

        int n = Integer.parseInt(input[0]), m = Integer.parseInt(input[1]), b = Integer.parseInt(input[2]), min = 501,
                max = -1;
        int[][] land = new int[n][m];

        for (int i = 0; i < n; i++) {
            input = br.readLine().split(" ");
            for (int j = 0; j < m; j++) {
                int t = Integer.parseInt(input[j]);
                land[i][j] = t;
                if (t < min)
                    min = t;
                if (t > max)
                    max = t;
            }
        }

        int minTime = Integer.MAX_VALUE, height = 0;
        for (int h = min; h <= max; h++) {
            int inven = b, time = 0;
            for (int[] row : land) {
                for (int land_h : row) {
                    int gap = land_h - h;
                    if (gap > 0) {
                        time += gap * 2;
                        inven += gap;
                    } else if (gap < 0) {
                        time -= gap;
                        inven += gap;
                    }
                }
            }
            if (inven < 0) {
                continue;
            }
            if (minTime >= time) {
                minTime = time;
                height = h;
            }

        }

        bw.write(minTime + " " + height);
        bw.flush();
    }
}

```
