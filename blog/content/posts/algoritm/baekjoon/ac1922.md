---
title: "네트워크 연결"
date: "2021-07-12T12:18:37.121Z"
template: "post"
draft: false
slug: "ac1922"
category: "알고리즘"
tags:
  - "알고리즘"
  - "백준"
  - "1922"
  - "그래프이론"
  - "최소 스패닝 트리"
  - "java"
description: "백준 1922번 문제"
socialImage: "/media/algorithm.png"
---

[![백준](https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png)](https://www.acmicpc.net/problem/1922)
<div style="text-align:center"><a href="https://www.acmicpc.net/problem/1922">https://www.acmicpc.net/problem/1922</a></div>

---

- <a href='https://m.blog.naver.com/kks227/220799105543'>최소 스패닝 트리</a>에 대한 문제이다.
- 연결 비용을 오름차순으로 정렬 후 연결 목록을 꺼내 부모노드가 다를때 같아지게 만들고, 같다면 넘겨서 모두를 잇는다.
- 유니온 파인드에 이어서 보면 매우 편하다.

---

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.PriorityQueue;
import java.util.StringTokenizer;
import java.util.stream.IntStream;

//비교를 위한 클래스 Node
class Node implements Comparable<Node>{
    //시작점,도착점,비용
    int start,end,cost;
    public Node(int start,int end, int cost){
        this.start = start;
        this.end = end;
        this.cost = cost;
    }

    //비용 오름차순으로 정렬하고 같을 경우 낮은 시작점을 앞으로 한다.
    @Override
    public int compareTo(Node o) {
        if(this.cost == o.cost)
            return this.start-o.start;
        return this.cost-o.cost;
    }
}


public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringBuilder sb;
    static int[] ar;


    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = null;
        int n = Integer.parseInt(br.readLine()),m = Integer.parseInt(br.readLine()),allCost=0;
        //부모노드 표기 자리에 본인 위치로 초기화한다.
        ar = IntStream.range(0, n+1).toArray();
        PriorityQueue<Node> q = new PriorityQueue<Node>();
        for(int i = 0; i < m; i++){
            st = new StringTokenizer(br.readLine());
            q.add(new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken())));
        }

        while(!q.isEmpty()){
            Node node = q.poll();
            //부모 노드가 같은지 확인하고 다르면 합친 뒤 필요한 비용에 더해준다.
            if(find(node.start)!=find(node.end)){
                union(node.start,node.end);
                allCost+=node.cost;
            }
        }
        bw.write(allCost+"");
        bw.flush();
    }

    //시작점의 부모와 도착점의 부모를 잇는다.
    private static void union(int start, int end) {
        ar[find(start)] = find(end);
    }

    //부모노드 위치에 본인 값이 들어있다면 본인이 최고 부모이므로 값을 반환한다.
    private static int find(int index) {
        if(ar[index]==index)return index;
        //그렇지 않을 경우 거슬러 올라가면서 부모값을 대입한다.
        return ar[index]=find(ar[index]);
    }
}
```